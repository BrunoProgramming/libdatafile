// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: logserver.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "logserver.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace mearec {

namespace {

const ::google::protobuf::Descriptor* RecordingStatusRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RecordingStatusRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* RecordingParamsReply_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RecordingParamsReply_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* RecordingParamsReply_StatusType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_logserver_2eproto() {
  protobuf_AddDesc_logserver_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "logserver.proto");
  GOOGLE_CHECK(file != NULL);
  RecordingStatusRequest_descriptor_ = file->message_type(0);
  static const int RecordingStatusRequest_offsets_[13] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingStatusRequest, size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingStatusRequest, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingStatusRequest, filename_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingStatusRequest, length_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingStatusRequest, nsamples_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingStatusRequest, nchannels_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingStatusRequest, lastvalidsample_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingStatusRequest, blocksize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingStatusRequest, samplerate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingStatusRequest, gain_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingStatusRequest, offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingStatusRequest, date_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingStatusRequest, time_),
  };
  RecordingStatusRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RecordingStatusRequest_descriptor_,
      RecordingStatusRequest::default_instance_,
      RecordingStatusRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingStatusRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingStatusRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RecordingStatusRequest));
  RecordingParamsReply_descriptor_ = file->message_type(1);
  static const int RecordingParamsReply_offsets_[13] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingParamsReply, size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingParamsReply, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingParamsReply, filename_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingParamsReply, length_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingParamsReply, nsamples_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingParamsReply, nchannels_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingParamsReply, lastvalidsample_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingParamsReply, blocksize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingParamsReply, samplerate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingParamsReply, gain_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingParamsReply, offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingParamsReply, date_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingParamsReply, time_),
  };
  RecordingParamsReply_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RecordingParamsReply_descriptor_,
      RecordingParamsReply::default_instance_,
      RecordingParamsReply_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingParamsReply, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordingParamsReply, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RecordingParamsReply));
  RecordingParamsReply_StatusType_descriptor_ = RecordingParamsReply_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_logserver_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RecordingStatusRequest_descriptor_, &RecordingStatusRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RecordingParamsReply_descriptor_, &RecordingParamsReply::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_logserver_2eproto() {
  delete RecordingStatusRequest::default_instance_;
  delete RecordingStatusRequest_reflection_;
  delete RecordingParamsReply::default_instance_;
  delete RecordingParamsReply_reflection_;
}

void protobuf_AddDesc_logserver_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\017logserver.proto\022\006mearec\"\365\001\n\026RecordingS"
    "tatusRequest\022\014\n\004size\030\001 \002(\r\022\014\n\004type\030\002 \001(\010"
    "\022\020\n\010filename\030\003 \001(\010\022\016\n\006length\030\004 \001(\010\022\020\n\010ns"
    "amples\030\005 \001(\010\022\021\n\tnchannels\030\006 \001(\010\022\027\n\017lastV"
    "alidSample\030\007 \001(\010\022\021\n\tblockSize\030\010 \001(\010\022\022\n\ns"
    "ampleRate\030\t \001(\010\022\014\n\004gain\030\n \001(\010\022\016\n\006offset\030"
    "\013 \001(\010\022\014\n\004date\030\014 \001(\010\022\014\n\004time\030\r \001(\010\"\246\002\n\024Re"
    "cordingParamsReply\022\014\n\004size\030\001 \002(\r\022\014\n\004type"
    "\030\002 \001(\t\022\020\n\010filename\030\003 \001(\t\022\016\n\006length\030\004 \001(\001"
    "\022\020\n\010nsamples\030\005 \001(\r\022\021\n\tnchannels\030\006 \001(\r\022\027\n"
    "\017lastValidSample\030\007 \001(\r\022\021\n\tblockSize\030\010 \001("
    "\r\022\022\n\nsampleRate\030\t \001(\002\022\014\n\004gain\030\n \001(\002\022\016\n\006o"
    "ffset\030\013 \001(\002\022\014\n\004date\030\014 \001(\t\022\014\n\004time\030\r \001(\t\""
    "1\n\nStatusType\022\013\n\007RUNNING\020\000\022\013\n\007STOPPED\020\001\022"
    "\t\n\005ERROR\020\002", 570);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "logserver.proto", &protobuf_RegisterTypes);
  RecordingStatusRequest::default_instance_ = new RecordingStatusRequest();
  RecordingParamsReply::default_instance_ = new RecordingParamsReply();
  RecordingStatusRequest::default_instance_->InitAsDefaultInstance();
  RecordingParamsReply::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_logserver_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_logserver_2eproto {
  StaticDescriptorInitializer_logserver_2eproto() {
    protobuf_AddDesc_logserver_2eproto();
  }
} static_descriptor_initializer_logserver_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int RecordingStatusRequest::kSizeFieldNumber;
const int RecordingStatusRequest::kTypeFieldNumber;
const int RecordingStatusRequest::kFilenameFieldNumber;
const int RecordingStatusRequest::kLengthFieldNumber;
const int RecordingStatusRequest::kNsamplesFieldNumber;
const int RecordingStatusRequest::kNchannelsFieldNumber;
const int RecordingStatusRequest::kLastValidSampleFieldNumber;
const int RecordingStatusRequest::kBlockSizeFieldNumber;
const int RecordingStatusRequest::kSampleRateFieldNumber;
const int RecordingStatusRequest::kGainFieldNumber;
const int RecordingStatusRequest::kOffsetFieldNumber;
const int RecordingStatusRequest::kDateFieldNumber;
const int RecordingStatusRequest::kTimeFieldNumber;
#endif  // !_MSC_VER

RecordingStatusRequest::RecordingStatusRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mearec.RecordingStatusRequest)
}

void RecordingStatusRequest::InitAsDefaultInstance() {
}

RecordingStatusRequest::RecordingStatusRequest(const RecordingStatusRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mearec.RecordingStatusRequest)
}

void RecordingStatusRequest::SharedCtor() {
  _cached_size_ = 0;
  size_ = 0u;
  type_ = false;
  filename_ = false;
  length_ = false;
  nsamples_ = false;
  nchannels_ = false;
  lastvalidsample_ = false;
  blocksize_ = false;
  samplerate_ = false;
  gain_ = false;
  offset_ = false;
  date_ = false;
  time_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RecordingStatusRequest::~RecordingStatusRequest() {
  // @@protoc_insertion_point(destructor:mearec.RecordingStatusRequest)
  SharedDtor();
}

void RecordingStatusRequest::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RecordingStatusRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RecordingStatusRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RecordingStatusRequest_descriptor_;
}

const RecordingStatusRequest& RecordingStatusRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logserver_2eproto();
  return *default_instance_;
}

RecordingStatusRequest* RecordingStatusRequest::default_instance_ = NULL;

RecordingStatusRequest* RecordingStatusRequest::New() const {
  return new RecordingStatusRequest;
}

void RecordingStatusRequest::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RecordingStatusRequest*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(size_, blocksize_);
  }
  if (_has_bits_[8 / 32] & 7936) {
    ZR_(samplerate_, time_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RecordingStatusRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mearec.RecordingStatusRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 size = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // optional bool type = 2;
      case 2: {
        if (tag == 16) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_filename;
        break;
      }

      // optional bool filename = 3;
      case 3: {
        if (tag == 24) {
         parse_filename:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &filename_)));
          set_has_filename();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_length;
        break;
      }

      // optional bool length = 4;
      case 4: {
        if (tag == 32) {
         parse_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &length_)));
          set_has_length();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_nsamples;
        break;
      }

      // optional bool nsamples = 5;
      case 5: {
        if (tag == 40) {
         parse_nsamples:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &nsamples_)));
          set_has_nsamples();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_nchannels;
        break;
      }

      // optional bool nchannels = 6;
      case 6: {
        if (tag == 48) {
         parse_nchannels:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &nchannels_)));
          set_has_nchannels();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_lastValidSample;
        break;
      }

      // optional bool lastValidSample = 7;
      case 7: {
        if (tag == 56) {
         parse_lastValidSample:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &lastvalidsample_)));
          set_has_lastvalidsample();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_blockSize;
        break;
      }

      // optional bool blockSize = 8;
      case 8: {
        if (tag == 64) {
         parse_blockSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &blocksize_)));
          set_has_blocksize();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_sampleRate;
        break;
      }

      // optional bool sampleRate = 9;
      case 9: {
        if (tag == 72) {
         parse_sampleRate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &samplerate_)));
          set_has_samplerate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_gain;
        break;
      }

      // optional bool gain = 10;
      case 10: {
        if (tag == 80) {
         parse_gain:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &gain_)));
          set_has_gain();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_offset;
        break;
      }

      // optional bool offset = 11;
      case 11: {
        if (tag == 88) {
         parse_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_date;
        break;
      }

      // optional bool date = 12;
      case 12: {
        if (tag == 96) {
         parse_date:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &date_)));
          set_has_date();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_time;
        break;
      }

      // optional bool time = 13;
      case 13: {
        if (tag == 104) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mearec.RecordingStatusRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mearec.RecordingStatusRequest)
  return false;
#undef DO_
}

void RecordingStatusRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mearec.RecordingStatusRequest)
  // required uint32 size = 1;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->size(), output);
  }

  // optional bool type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->type(), output);
  }

  // optional bool filename = 3;
  if (has_filename()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->filename(), output);
  }

  // optional bool length = 4;
  if (has_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->length(), output);
  }

  // optional bool nsamples = 5;
  if (has_nsamples()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->nsamples(), output);
  }

  // optional bool nchannels = 6;
  if (has_nchannels()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->nchannels(), output);
  }

  // optional bool lastValidSample = 7;
  if (has_lastvalidsample()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->lastvalidsample(), output);
  }

  // optional bool blockSize = 8;
  if (has_blocksize()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->blocksize(), output);
  }

  // optional bool sampleRate = 9;
  if (has_samplerate()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->samplerate(), output);
  }

  // optional bool gain = 10;
  if (has_gain()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->gain(), output);
  }

  // optional bool offset = 11;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->offset(), output);
  }

  // optional bool date = 12;
  if (has_date()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->date(), output);
  }

  // optional bool time = 13;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->time(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mearec.RecordingStatusRequest)
}

::google::protobuf::uint8* RecordingStatusRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mearec.RecordingStatusRequest)
  // required uint32 size = 1;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->size(), target);
  }

  // optional bool type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->type(), target);
  }

  // optional bool filename = 3;
  if (has_filename()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->filename(), target);
  }

  // optional bool length = 4;
  if (has_length()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->length(), target);
  }

  // optional bool nsamples = 5;
  if (has_nsamples()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->nsamples(), target);
  }

  // optional bool nchannels = 6;
  if (has_nchannels()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->nchannels(), target);
  }

  // optional bool lastValidSample = 7;
  if (has_lastvalidsample()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->lastvalidsample(), target);
  }

  // optional bool blockSize = 8;
  if (has_blocksize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->blocksize(), target);
  }

  // optional bool sampleRate = 9;
  if (has_samplerate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(9, this->samplerate(), target);
  }

  // optional bool gain = 10;
  if (has_gain()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(10, this->gain(), target);
  }

  // optional bool offset = 11;
  if (has_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(11, this->offset(), target);
  }

  // optional bool date = 12;
  if (has_date()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(12, this->date(), target);
  }

  // optional bool time = 13;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(13, this->time(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mearec.RecordingStatusRequest)
  return target;
}

int RecordingStatusRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 size = 1;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->size());
    }

    // optional bool type = 2;
    if (has_type()) {
      total_size += 1 + 1;
    }

    // optional bool filename = 3;
    if (has_filename()) {
      total_size += 1 + 1;
    }

    // optional bool length = 4;
    if (has_length()) {
      total_size += 1 + 1;
    }

    // optional bool nsamples = 5;
    if (has_nsamples()) {
      total_size += 1 + 1;
    }

    // optional bool nchannels = 6;
    if (has_nchannels()) {
      total_size += 1 + 1;
    }

    // optional bool lastValidSample = 7;
    if (has_lastvalidsample()) {
      total_size += 1 + 1;
    }

    // optional bool blockSize = 8;
    if (has_blocksize()) {
      total_size += 1 + 1;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bool sampleRate = 9;
    if (has_samplerate()) {
      total_size += 1 + 1;
    }

    // optional bool gain = 10;
    if (has_gain()) {
      total_size += 1 + 1;
    }

    // optional bool offset = 11;
    if (has_offset()) {
      total_size += 1 + 1;
    }

    // optional bool date = 12;
    if (has_date()) {
      total_size += 1 + 1;
    }

    // optional bool time = 13;
    if (has_time()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RecordingStatusRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RecordingStatusRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RecordingStatusRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RecordingStatusRequest::MergeFrom(const RecordingStatusRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_size()) {
      set_size(from.size());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_filename()) {
      set_filename(from.filename());
    }
    if (from.has_length()) {
      set_length(from.length());
    }
    if (from.has_nsamples()) {
      set_nsamples(from.nsamples());
    }
    if (from.has_nchannels()) {
      set_nchannels(from.nchannels());
    }
    if (from.has_lastvalidsample()) {
      set_lastvalidsample(from.lastvalidsample());
    }
    if (from.has_blocksize()) {
      set_blocksize(from.blocksize());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_samplerate()) {
      set_samplerate(from.samplerate());
    }
    if (from.has_gain()) {
      set_gain(from.gain());
    }
    if (from.has_offset()) {
      set_offset(from.offset());
    }
    if (from.has_date()) {
      set_date(from.date());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RecordingStatusRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RecordingStatusRequest::CopyFrom(const RecordingStatusRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecordingStatusRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RecordingStatusRequest::Swap(RecordingStatusRequest* other) {
  if (other != this) {
    std::swap(size_, other->size_);
    std::swap(type_, other->type_);
    std::swap(filename_, other->filename_);
    std::swap(length_, other->length_);
    std::swap(nsamples_, other->nsamples_);
    std::swap(nchannels_, other->nchannels_);
    std::swap(lastvalidsample_, other->lastvalidsample_);
    std::swap(blocksize_, other->blocksize_);
    std::swap(samplerate_, other->samplerate_);
    std::swap(gain_, other->gain_);
    std::swap(offset_, other->offset_);
    std::swap(date_, other->date_);
    std::swap(time_, other->time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RecordingStatusRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RecordingStatusRequest_descriptor_;
  metadata.reflection = RecordingStatusRequest_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* RecordingParamsReply_StatusType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RecordingParamsReply_StatusType_descriptor_;
}
bool RecordingParamsReply_StatusType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const RecordingParamsReply_StatusType RecordingParamsReply::RUNNING;
const RecordingParamsReply_StatusType RecordingParamsReply::STOPPED;
const RecordingParamsReply_StatusType RecordingParamsReply::ERROR;
const RecordingParamsReply_StatusType RecordingParamsReply::StatusType_MIN;
const RecordingParamsReply_StatusType RecordingParamsReply::StatusType_MAX;
const int RecordingParamsReply::StatusType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int RecordingParamsReply::kSizeFieldNumber;
const int RecordingParamsReply::kTypeFieldNumber;
const int RecordingParamsReply::kFilenameFieldNumber;
const int RecordingParamsReply::kLengthFieldNumber;
const int RecordingParamsReply::kNsamplesFieldNumber;
const int RecordingParamsReply::kNchannelsFieldNumber;
const int RecordingParamsReply::kLastValidSampleFieldNumber;
const int RecordingParamsReply::kBlockSizeFieldNumber;
const int RecordingParamsReply::kSampleRateFieldNumber;
const int RecordingParamsReply::kGainFieldNumber;
const int RecordingParamsReply::kOffsetFieldNumber;
const int RecordingParamsReply::kDateFieldNumber;
const int RecordingParamsReply::kTimeFieldNumber;
#endif  // !_MSC_VER

RecordingParamsReply::RecordingParamsReply()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mearec.RecordingParamsReply)
}

void RecordingParamsReply::InitAsDefaultInstance() {
}

RecordingParamsReply::RecordingParamsReply(const RecordingParamsReply& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mearec.RecordingParamsReply)
}

void RecordingParamsReply::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  size_ = 0u;
  type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  length_ = 0;
  nsamples_ = 0u;
  nchannels_ = 0u;
  lastvalidsample_ = 0u;
  blocksize_ = 0u;
  samplerate_ = 0;
  gain_ = 0;
  offset_ = 0;
  date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RecordingParamsReply::~RecordingParamsReply() {
  // @@protoc_insertion_point(destructor:mearec.RecordingParamsReply)
  SharedDtor();
}

void RecordingParamsReply::SharedDtor() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filename_;
  }
  if (date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete date_;
  }
  if (time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete time_;
  }
  if (this != default_instance_) {
  }
}

void RecordingParamsReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RecordingParamsReply::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RecordingParamsReply_descriptor_;
}

const RecordingParamsReply& RecordingParamsReply::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logserver_2eproto();
  return *default_instance_;
}

RecordingParamsReply* RecordingParamsReply::default_instance_ = NULL;

RecordingParamsReply* RecordingParamsReply::New() const {
  return new RecordingParamsReply;
}

void RecordingParamsReply::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RecordingParamsReply*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(size_, blocksize_);
    if (has_type()) {
      if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        type_->clear();
      }
    }
    if (has_filename()) {
      if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        filename_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & 7936) {
    ZR_(samplerate_, offset_);
    if (has_date()) {
      if (date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        date_->clear();
      }
    }
    if (has_time()) {
      if (time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        time_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RecordingParamsReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mearec.RecordingParamsReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 size = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_type;
        break;
      }

      // optional string type = 2;
      case 2: {
        if (tag == 18) {
         parse_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->type().data(), this->type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_filename;
        break;
      }

      // optional string filename = 3;
      case 3: {
        if (tag == 26) {
         parse_filename:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->filename().data(), this->filename().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "filename");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_length;
        break;
      }

      // optional double length = 4;
      case 4: {
        if (tag == 33) {
         parse_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &length_)));
          set_has_length();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_nsamples;
        break;
      }

      // optional uint32 nsamples = 5;
      case 5: {
        if (tag == 40) {
         parse_nsamples:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nsamples_)));
          set_has_nsamples();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_nchannels;
        break;
      }

      // optional uint32 nchannels = 6;
      case 6: {
        if (tag == 48) {
         parse_nchannels:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nchannels_)));
          set_has_nchannels();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_lastValidSample;
        break;
      }

      // optional uint32 lastValidSample = 7;
      case 7: {
        if (tag == 56) {
         parse_lastValidSample:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lastvalidsample_)));
          set_has_lastvalidsample();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_blockSize;
        break;
      }

      // optional uint32 blockSize = 8;
      case 8: {
        if (tag == 64) {
         parse_blockSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &blocksize_)));
          set_has_blocksize();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(77)) goto parse_sampleRate;
        break;
      }

      // optional float sampleRate = 9;
      case 9: {
        if (tag == 77) {
         parse_sampleRate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &samplerate_)));
          set_has_samplerate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(85)) goto parse_gain;
        break;
      }

      // optional float gain = 10;
      case 10: {
        if (tag == 85) {
         parse_gain:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &gain_)));
          set_has_gain();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(93)) goto parse_offset;
        break;
      }

      // optional float offset = 11;
      case 11: {
        if (tag == 93) {
         parse_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_date;
        break;
      }

      // optional string date = 12;
      case 12: {
        if (tag == 98) {
         parse_date:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_date()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->date().data(), this->date().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "date");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_time;
        break;
      }

      // optional string time = 13;
      case 13: {
        if (tag == 106) {
         parse_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_time()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->time().data(), this->time().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "time");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mearec.RecordingParamsReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mearec.RecordingParamsReply)
  return false;
#undef DO_
}

void RecordingParamsReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mearec.RecordingParamsReply)
  // required uint32 size = 1;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->size(), output);
  }

  // optional string type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->type(), output);
  }

  // optional string filename = 3;
  if (has_filename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->filename().data(), this->filename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "filename");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->filename(), output);
  }

  // optional double length = 4;
  if (has_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->length(), output);
  }

  // optional uint32 nsamples = 5;
  if (has_nsamples()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->nsamples(), output);
  }

  // optional uint32 nchannels = 6;
  if (has_nchannels()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->nchannels(), output);
  }

  // optional uint32 lastValidSample = 7;
  if (has_lastvalidsample()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->lastvalidsample(), output);
  }

  // optional uint32 blockSize = 8;
  if (has_blocksize()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->blocksize(), output);
  }

  // optional float sampleRate = 9;
  if (has_samplerate()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->samplerate(), output);
  }

  // optional float gain = 10;
  if (has_gain()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->gain(), output);
  }

  // optional float offset = 11;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(11, this->offset(), output);
  }

  // optional string date = 12;
  if (has_date()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->date().data(), this->date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "date");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      12, this->date(), output);
  }

  // optional string time = 13;
  if (has_time()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->time().data(), this->time().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "time");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      13, this->time(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mearec.RecordingParamsReply)
}

::google::protobuf::uint8* RecordingParamsReply::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mearec.RecordingParamsReply)
  // required uint32 size = 1;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->size(), target);
  }

  // optional string type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->type(), target);
  }

  // optional string filename = 3;
  if (has_filename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->filename().data(), this->filename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "filename");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->filename(), target);
  }

  // optional double length = 4;
  if (has_length()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->length(), target);
  }

  // optional uint32 nsamples = 5;
  if (has_nsamples()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->nsamples(), target);
  }

  // optional uint32 nchannels = 6;
  if (has_nchannels()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->nchannels(), target);
  }

  // optional uint32 lastValidSample = 7;
  if (has_lastvalidsample()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->lastvalidsample(), target);
  }

  // optional uint32 blockSize = 8;
  if (has_blocksize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->blocksize(), target);
  }

  // optional float sampleRate = 9;
  if (has_samplerate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->samplerate(), target);
  }

  // optional float gain = 10;
  if (has_gain()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(10, this->gain(), target);
  }

  // optional float offset = 11;
  if (has_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(11, this->offset(), target);
  }

  // optional string date = 12;
  if (has_date()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->date().data(), this->date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "date");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        12, this->date(), target);
  }

  // optional string time = 13;
  if (has_time()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->time().data(), this->time().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "time");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        13, this->time(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mearec.RecordingParamsReply)
  return target;
}

int RecordingParamsReply::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 size = 1;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->size());
    }

    // optional string type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->type());
    }

    // optional string filename = 3;
    if (has_filename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filename());
    }

    // optional double length = 4;
    if (has_length()) {
      total_size += 1 + 8;
    }

    // optional uint32 nsamples = 5;
    if (has_nsamples()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nsamples());
    }

    // optional uint32 nchannels = 6;
    if (has_nchannels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nchannels());
    }

    // optional uint32 lastValidSample = 7;
    if (has_lastvalidsample()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lastvalidsample());
    }

    // optional uint32 blockSize = 8;
    if (has_blocksize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->blocksize());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float sampleRate = 9;
    if (has_samplerate()) {
      total_size += 1 + 4;
    }

    // optional float gain = 10;
    if (has_gain()) {
      total_size += 1 + 4;
    }

    // optional float offset = 11;
    if (has_offset()) {
      total_size += 1 + 4;
    }

    // optional string date = 12;
    if (has_date()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->date());
    }

    // optional string time = 13;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->time());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RecordingParamsReply::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RecordingParamsReply* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RecordingParamsReply*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RecordingParamsReply::MergeFrom(const RecordingParamsReply& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_size()) {
      set_size(from.size());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_filename()) {
      set_filename(from.filename());
    }
    if (from.has_length()) {
      set_length(from.length());
    }
    if (from.has_nsamples()) {
      set_nsamples(from.nsamples());
    }
    if (from.has_nchannels()) {
      set_nchannels(from.nchannels());
    }
    if (from.has_lastvalidsample()) {
      set_lastvalidsample(from.lastvalidsample());
    }
    if (from.has_blocksize()) {
      set_blocksize(from.blocksize());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_samplerate()) {
      set_samplerate(from.samplerate());
    }
    if (from.has_gain()) {
      set_gain(from.gain());
    }
    if (from.has_offset()) {
      set_offset(from.offset());
    }
    if (from.has_date()) {
      set_date(from.date());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RecordingParamsReply::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RecordingParamsReply::CopyFrom(const RecordingParamsReply& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecordingParamsReply::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RecordingParamsReply::Swap(RecordingParamsReply* other) {
  if (other != this) {
    std::swap(size_, other->size_);
    std::swap(type_, other->type_);
    std::swap(filename_, other->filename_);
    std::swap(length_, other->length_);
    std::swap(nsamples_, other->nsamples_);
    std::swap(nchannels_, other->nchannels_);
    std::swap(lastvalidsample_, other->lastvalidsample_);
    std::swap(blocksize_, other->blocksize_);
    std::swap(samplerate_, other->samplerate_);
    std::swap(gain_, other->gain_);
    std::swap(offset_, other->offset_);
    std::swap(date_, other->date_);
    std::swap(time_, other->time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RecordingParamsReply::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RecordingParamsReply_descriptor_;
  metadata.reflection = RecordingParamsReply_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mearec

// @@protoc_insertion_point(global_scope)
